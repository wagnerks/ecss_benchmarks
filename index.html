<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>ecss benchmarks</title>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		a {
			color: #4ea3ff;
			text-decoration: none;
		}

		a:hover {
			text-decoration: underline;
			color: #82cfff;
		}

		body {
			margin: 0;
			font-family: sans-serif;
			background: #121212;
			color: #e0e0e0;
		}

		#charts {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			grid-gap: 20px;
			padding: 20px;
			box-sizing: border-box;
		}

		.chart-container {
			background: #1e1e1e;
			border-radius: 8px;
			padding: 10px;
			box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
			height: 200px;
		}

		canvas {
			width: 100% !important;
			height: 100% !important;
		}

		.section-separator {
			border: none;
			height: 1px;
			margin: 1px 0;
			background: linear-gradient(to right, transparent, #444, transparent);
			width: 100%;
		}

		.result-table {
			display: flex;
			flex-direction: column;
			gap: 6px;
			font-family: monospace;
		}

		.result-table .row {
			display: flex;
			justify-content: space-between;
			padding: 2px 6px;
			background: #1e1e1e;
			border-radius: 4px;
		}

		.result-table .name {
			color: #e0e0e0;
		}

		.result-table .value {
			color: #82cfff;
		}

		.info-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 40px;
			margin-bottom: 20px;
		}

		.info-grid h3 {
			margin-top: 0;
		}

		#system-info pre,
		#ecss-summary pre {
			background: #1e1e1e;
			padding: 10px;
			border-radius: 6px;
			overflow-x: auto;
		}

		.compare-slider {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 40px;
			align-items: start;
			padding: 10px;
			max-width: 1920px;
			margin: 0 auto;
			box-sizing: border-box;
		}

		.compare-text {
			line-height: 1.6;
		}

		#entitySliderWrapper {
			background: rgba(30, 30, 30, 0.6);
			border-radius: 8px;
			padding: 12px 16px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
			opacity: 0.9;
		}

		#entitySliderWrapper:hover {
			background: rgba(30, 30, 30, 0.9);
			opacity: 1;
		}

		#entitySliderWrapper label {
			font-size: 13px;
			margin-bottom: 6px;
			display: block;
			color: #ddd;
		}

		#entityCount {
			width: 100%;
		}

		#sliderTicks {
			display: flex;
			justify-content: space-between;
			margin-top: 4px;
			font-size: 11px;
			color: #aaa;
			font-family: monospace;
		}
	</style>
</head>

<body>
	<div style="padding:10px; max-width:1920px; margin:0 auto; line-height:1.6;">
		<h2><a href="https://github.com/wagnerks/ecss_benchmarks" target="_blank">ECSS Benchmarks</a>, <a
				href="https://github.com/wagnerks/ecss" target="_blank">ecss</a> – sector/chunk based ECS
		</h2>

		<div class="info-grid">
			<div>
				<h3>System Info</h3>
				<div id="system-info"></div>
			</div>
			<div>
				<h3>ecss – 1M entity results</h3>
				<div id="ecss-summary"></div>
			</div>
		</div>
	</div>
	
	<hr class="section-separator">

	<div class="compare-slider">
		<div class="compare-text">
			<h3>Compared to:</h3>
			<ul>
				<li><a href="https://github.com/skypjack/entt" target="_blank">EnTT</a> – is a header-only, tiny and
					easy to use library for game programming and much more written in modern C++.</li>
				<li><a href="https://github.com/SanderMertens/flecs" target="_blank">Flecs</a> – Flecs is a fast and
					lightweight Entity Component System that lets you build games and simulations with millions of
					entities
				</li>
			</ul>
			<p>
				<strong>Lower values mean better performance.</strong><br>
				Bars show relative performance with <strong>ecss = 1×</strong> as the baseline.
				Other ecs are divided by the ecss result, so you can directly compare how
				many times slower or faster they are. Absolute times in microseconds (µs) are
				available in tooltips when hovering over a bar.
			</p>
		</div>

		<div id="entitySliderWrapper">
			<label for="entityCount">
				Entities count in benchmark: <span id="entityLabel"></span>
			</label>
			<input type="range" id="entityCount" min="0" step="1" value="0" onfocus="this.blur()">
			<div class="ticks" id="sliderTicks"></div>
		</div>
	</div>

	<div id="charts-wrapper">
		<div id="charts"></div>
	</div>

	<script>
		let charts = {};
		let allGroups = {};
		let availableSizes = [];
		let currentIndex = 0;

		function formatNumberShort(n) {
			if (n >= 1_000_000) return (n / 1_000_000) + "M";
			if (n >= 1_000) return (n / 1_000) + "K";
			return n.toString();
		}

		function updateSliderLabel() {
			document.getElementById("entityLabel").textContent =
				formatNumberShort(availableSizes[currentIndex]);
		}

		async function loadSummary(json) {
			const ctx = json.context;
			const sysInfo = [
				`Date: ${ctx.date}`,
				`Host: ${ctx.host_name}`,
				`Executable: ${ctx.executable}`,
				`CPU cores: ${ctx.num_cpus}`,
				`Clock: ${ctx.mhz_per_cpu} MHz`,
				`CPU scaling: ${ctx.cpu_scaling_enabled ? "enabled" : "disabled"}`,
				`Build type: ${ctx.library_build_type}`,
				`Load avg: ${ctx.load_avg.join(", ")}`
			];
			if (ctx.caches && ctx.caches.length > 0) {
				sysInfo.push("Caches:");
				ctx.caches.forEach(c => {
					sysInfo.push(`  L${c.level} ${c.type} – ${c.size / 1024} KB (shared by ${c.num_sharing})`);
				});
			}
			document.getElementById('system-info').innerHTML =
				"<pre>" + sysInfo.join("\n") + "</pre>";

			const oneM = {};
			json.benchmarks.forEach(b => {
				const match = b.name.match(/ecss.*?([a-zA-Z_]+)\/1000000/);
				if (match) {
					const [, testName] = match;
					oneM[testName] = Math.round(b.cpu_time);
				}
			});

			let html = "<div class='result-table'>";
			Object.entries(oneM).forEach(([test, val]) => {
				html += `<div class="row"><span class="name">${test}</span><span class="value">${val} µs</span></div>`;
			});
			html += "</div>";
			document.getElementById("ecss-summary").innerHTML = html;
		}

		async function loadData() {
			const response = await fetch('results.json?ts=' + Date.now());
			const json = await response.json();
			loadSummary(json);

			const groups = {};
			const sizesSet = new Set();

			json.benchmarks.forEach(b => {
				const match = b.name.match(/(ecss|entt|flecs).*?([a-zA-Z_]+)\/(\d+)$/);
				if (!match) return;
				const [, ecs, rawName, size] = match;
				const testName = rawName.replace(/[^a-zA-Z0-9_]/g, '');

				if (!groups[testName]) groups[testName] = {};
				if (!groups[testName][size]) groups[testName][size] = {};
				groups[testName][size][ecs] = b.cpu_time;
				sizesSet.add(parseInt(size));
			});

			allGroups = groups;
			availableSizes = Array.from(sizesSet).sort((a, b) => a - b);

			const slider = document.getElementById('entityCount');
			slider.max = availableSizes.length - 1;
			slider.value = availableSizes.length - 1;
			currentIndex = parseInt(slider.value, 10);

			const ticksDiv = document.getElementById('sliderTicks');
			ticksDiv.innerHTML = availableSizes.map(s => `<span>${formatNumberShort(s)}</span>`).join('');

			renderCharts(availableSizes[currentIndex]);
			updateSliderLabel();

			slider.addEventListener('input', (e) => {
				currentIndex = parseInt(e.target.value, 10);
				updateChartsData(availableSizes[currentIndex]);
				updateSliderLabel();
			});
		}

		function prepareData(sizeData) {
			const ecssData = sizeData.ecss || 1;
			return [
				1,
				sizeData.entt ? sizeData.entt / ecssData : null,
				sizeData.flecs ? sizeData.flecs / ecssData : null
			];
		}

		function setCustomTicks(chart, newData) {
			const ticks = newData.filter(v => v !== null);
			chart.options.scales.y.afterBuildTicks = (axis) => {
				axis.ticks = ticks.map(v => ({ value: v }));
			};
		}

		const valueOnBars = {
			id: 'valueOnBars',
			afterDatasetsDraw(chart) {
				const { ctx } = chart;
				ctx.save();
				chart.data.datasets.forEach((dataset, i) => {
					const meta = chart.getDatasetMeta(i);
					meta.data.forEach((bar, index) => {
						const val = dataset.data[index];
						if (val !== null && val !== undefined) {
							const sizeData = allGroups[dataset.label][availableSizes[currentIndex]];
							const ecssVal = sizeData.ecss || 1;
							let absVal = null;
							if (index === 0) absVal = ecssVal;
							if (index === 1 && sizeData.entt) absVal = sizeData.entt;
							if (index === 2 && sizeData.flecs) absVal = sizeData.flecs;

							ctx.fillStyle = '#fff';
							ctx.font = '12px sans-serif';
							ctx.textAlign = 'center';
							function formatRatio(val) {
								if (Math.abs(val - Math.round(val)) < 1e-6) {
									return Math.round(val).toString();
								}
								if (val < 5) {
									return val.toFixed(2);
								}
								return Math.round(val).toString();
							}

							ctx.fillText(
								formatRatio(val) + "×",
								bar.x,
								bar.y - 5
							);
						}
					});
				});
			}
		};

		function renderCharts(entityCount) {
			const chartsDiv = document.getElementById('charts');
			chartsDiv.innerHTML = '';

			Object.entries(allGroups).forEach(([testName, sizes]) => {
				if (!sizes[entityCount]) return;

				const container = document.createElement('div');
				container.className = 'chart-container';
				const canvas = document.createElement('canvas');
				canvas.dataset.test = testName;
				container.appendChild(canvas);
				chartsDiv.appendChild(container);

				const chartData = prepareData(sizes[entityCount]);
				const chart = new Chart(canvas.getContext('2d'), {
					type: 'bar',
					data: {
						labels: ['ecss', 'entt', 'flecs'],
						datasets: [{
							label: testName,
							data: chartData,
							backgroundColor: [
								'rgba(145, 121, 201, 0.7)',
								'rgba(50, 128, 50, 0.7)',
								'rgba(200, 100, 50, 0.7)'
							],
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						animation: { duration: 0 },
						plugins: {
							legend: { display: false },
							title: {
								display: true,
								text: testName,
								color: '#fff',
								font: { size: 14 }
							},
							tooltip: {
								displayColors: false,
								callbacks: {
									title: () => [],
									label: (ctx) => {
										const sizeData = allGroups[testName][entityCount];
										const ecssVal = sizeData.ecss || 1;

										if (ctx.dataIndex === 0)
											return `${ecssVal.toFixed(0)} µs`;
										if (ctx.dataIndex === 1 && sizeData.entt) {
											const ratio = sizeData.entt / ecssVal;
											return `${sizeData.entt.toFixed(0)} µs`;
										}
										if (ctx.dataIndex === 2 && sizeData.flecs) {
											const ratio = sizeData.flecs / ecssVal;
											return `${sizeData.flecs.toFixed(0)} µs`;
										}
										return "";
									}
								}
							}
						},
						scales: {
							y: {
								type: 'linear',
								ticks: {
									display: false,
									color: '#fff',
									font: { size: 12 },
									callback: (value) => value.toFixed(2) + "×"
								},
								grid: {
									display: false,
									color: "#444",
									drawOnChartArea: true
								},
								afterBuildTicks: (axis) => {
									const chartData = axis.chart.data.datasets[0].data;
									const ticks = chartData.filter(v => v !== null);
									axis.ticks = ticks.map(v => ({ value: v }));
								},
								border: {
									display: false,
									color: "#888"
								}
							},
							x: {
								ticks: {
									color: '#fff',
									font: { size: 12 }
								},
								grid: {
									display: false,
									color: "#444"
								},
								border: {
									color: "#888"
								}
							}
						}
					},
					plugins: [valueOnBars]
				});

				setCustomTicks(chart, chartData);
				charts[testName] = chart;
			});
		}

		function updateChartsData(entityCount) {
			Object.entries(allGroups).forEach(([testName, sizes]) => {
				if (!sizes[entityCount]) return;
				const chart = charts[testName];
				if (!chart) return;

				const newData = prepareData(sizes[entityCount]);
				chart.data.datasets[0].data = newData;
				setCustomTicks(chart, newData);

				chart.update();
			});
		}

		loadData();
	</script>
</body>

</html>