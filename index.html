<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>ecss vs other ecs benchmarks</title>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		a {
			color: #4ea3ff;
			text-decoration: none;
		}

		a:hover {
			text-decoration: underline;
			color: #82cfff;
		}

		body {
			margin: 0;
			font-family: sans-serif;
			background: #121212;
			color: #e0e0e0;
		}

		#charts {
			display: grid;
			grid-template-columns: repeat(5, 1fr);
			grid-gap: 20px;
			padding: 20px;
			box-sizing: border-box;
		}

		.chart-container {
			background: #1e1e1e;
			border-radius: 8px;
			padding: 10px;
			box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
			height: 300px;
		}

		canvas {
			width: 100% !important;
			height: 100% !important;
		}

		.section-separator {
			border: none;
			height: 1px;
			margin: 1px 0;
			background: linear-gradient(to right, transparent, #444, transparent);
			width: 100%;
		}

		.result-table {
			display: flex;
			flex-direction: column;
			gap: 6px;
			font-family: monospace;
		}

		.result-table .row {
			display: flex;
			justify-content: space-between;
			padding: 2px 6px;
			background: #1e1e1e;
			border-radius: 4px;
		}

		.result-table .name {
			color: #e0e0e0;
		}

		.result-table .value {
			color: #82cfff;
		}

		.info-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 40px;
			margin-bottom: 20px;
		}

		.info-grid h3 {
			margin-top: 0;
		}

		#system-info pre,
		#ecss-summary pre {
			background: #1e1e1e;
			padding: 10px;
			border-radius: 6px;
			overflow-x: auto;
		}

		/* ===== Slider window styles ===== */
		#entitySliderWrapper {
			position: fixed;
			bottom: 20px;
			right: 20px;
			background: rgba(30, 30, 30, 0.9);
			border: 1px solid #444;
			border-radius: 12px;
			padding: 15px 20px;
			box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
			display: none;
			z-index: 2000;
			transition: opacity 0.3s;
			opacity: 0.6;
			width: 300px;
			cursor: move;
			/* показываем что можно таскать */
		}

		#entitySliderWrapper:hover {
			opacity: 1;
		}

		#entityCount {
			width: 100%;
		}

		#sliderTicks {
			display: flex;
			justify-content: space-between;
			font-size: 12px;
			color: #aaa;
			font-family: monospace;
			margin-top: 6px;
		}
	</style>
</head>

<body>
	<div style="padding:20px; max-width:1920px; margin:0 auto; line-height:1.6;">
		<h2>ECSS Benchmarks</h2>
		<div class="info-grid">
			<div>
				<h3>System Info</h3>
				<div id="system-info"></div>
			</div>
			<div>
				<h3>ecss – 1M entity results</h3>
				<div id="ecss-summary"></div>
			</div>
		</div>
	</div>

	<hr class="section-separator">

	<div style="padding:20px; max-width:1920px; margin:0 auto; line-height:1.6;">
		<h2>About these benchmarks:</h2>
		<p>
			Times are reported in microseconds (µs) per operation, across varying entity counts.
		</p>

		<h3>Compared ECS libraries</h3>
		<ul>
			<li><a href="https://github.com/wagnerks/ecss" target="_blank">ecss</a> – sector/chunk based ECS (this repo)</li>
			<li><a href="https://github.com/skypjack/entt" target="_blank">EnTT</a> – is a header-only, tiny and easy to use
				library for game programming and much more written in modern C++.</li>
		</ul>

		<p>
			Benchmark sources live here:
			<a href="https://github.com/wagnerks/ecss_benchmarks" target="_blank">wagnerks/ecss_benchmarks</a>.
		</p>
		<p>
			<strong>Lower values mean better performance.</strong>
			Times are reported in <strong>microseconds (µs) per operation</strong>, across varying entity counts.
		</p>
	</div>

	<div id="charts"></div>

	<!-- Slider panel -->
	<div id="entitySliderWrapper">
		<label for="entityCount" style="display:block; margin-bottom:6px; font-size:13px; color:#ccc;">
			Entities count in benchmark:
		</label>
		<input type="range" id="entityCount" min="0" step="1" value="0">
		<div class="ticks" id="sliderTicks"></div>
	</div>

	<script>
		let charts = [];
		let allGroups = {};
		let availableSizes = [];
		let currentIndex = 0;

		function formatNumberShort(n) {
			if (n >= 1_000_000) return (n / 1_000_000) + "M";
			if (n >= 1_000) return (n / 1_000) + "K";
			return n.toString();
		}

		async function loadSummary(json) {
			const ctx = json.context;

			const sysInfo = [
				`Date: ${ctx.date}`,
				`Host: ${ctx.host_name}`,
				`Executable: ${ctx.executable}`,
				`CPU cores: ${ctx.num_cpus}`,
				`Clock: ${ctx.mhz_per_cpu} MHz`,
				`CPU scaling: ${ctx.cpu_scaling_enabled ? "enabled" : "disabled"}`,
				`Build type: ${ctx.library_build_type}`,
				`Load avg: ${ctx.load_avg.join(", ")}`
			];

			if (ctx.caches && ctx.caches.length > 0) {
				sysInfo.push("Caches:");
				ctx.caches.forEach(c => {
					sysInfo.push(`  L${c.level} ${c.type} – ${c.size / 1024} KB (shared by ${c.num_sharing})`);
				});
			}

			document.getElementById('system-info').innerHTML =
				"<pre>" + sysInfo.join("\n") + "</pre>";

			const oneM = {};
			json.benchmarks.forEach(b => {
				const match = b.name.match(/ecss.*?([a-zA-Z_]+)\/1000000/);
				if (match) {
					const [, testName] = match;
					oneM[testName] = Math.round(b.cpu_time);
				}
			});

			let html = "<div class='result-table'>";
			Object.entries(oneM).forEach(([test, val]) => {
				html += `<div class="row"><span class="name">${test}</span><span class="value">${val} µs</span></div>`;
			});
			html += "</div>";

			document.getElementById("ecss-summary").innerHTML = html;
		}

		async function loadData() {
			const response = await fetch('results.json');
			const json = await response.json();
			loadSummary(json);

			const groups = {};
			const sizesSet = new Set();

			json.benchmarks.forEach(b => {
				const match = b.name.match(/(ecss|entt).*?([a-zA-Z_]+)\/(\d+)/);
				if (!match) return;
				const [, ecs, testName, size] = match;
				if (!groups[testName]) groups[testName] = {};
				if (!groups[testName][size]) groups[testName][size] = {};
				groups[testName][size][ecs] = b.cpu_time;
				sizesSet.add(parseInt(size));
			});

			allGroups = groups;
			availableSizes = Array.from(sizesSet).sort((a, b) => a - b);

			const slider = document.getElementById('entityCount');
			slider.max = availableSizes.length - 1;
			slider.value = availableSizes.length - 1;
			currentIndex = parseInt(slider.value, 10);

			const ticksDiv = document.getElementById('sliderTicks');
			ticksDiv.innerHTML = availableSizes.map(s => `<span>${formatNumberShort(s)}</span>`).join('');

			renderCharts(availableSizes[currentIndex]);

			slider.addEventListener('input', (e) => {
				currentIndex = parseInt(e.target.value, 10);
				renderCharts(availableSizes[currentIndex]);
			});
		}

		function renderCharts(entityCount) {
			const chartsDiv = document.getElementById('charts');
			chartsDiv.innerHTML = '';
			charts = [];

			Object.entries(allGroups).forEach(([testName, sizes]) => {
				if (!sizes[entityCount]) return;

				const container = document.createElement('div');
				container.className = 'chart-container';
				const canvas = document.createElement('canvas');
				container.appendChild(canvas);
				chartsDiv.appendChild(container);

				const ecssData = sizes[entityCount].ecss || null;
				const enttData = sizes[entityCount].entt || null;

				const chart = new Chart(canvas.getContext('2d'), {
					type: 'bar',
					data: {
						labels: ['ecss', 'entt'],
						datasets: [{
							label: testName,
							data: [ecssData, enttData],
							backgroundColor: ['rgba(145, 121, 201, 0.7)', 'rgba(50, 128, 50, 0.7)']
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						animation: {
							duration: 0
						},
						plugins: {
							title: {
								display: true,
								text: testName,
								color: '#fff',
								font: { size: 14 }
							},
							legend: { display: false }
						},
						scales: {
							y: {
								beginAtZero: true,
								ticks: {
									color: '#fff',
									font: { size: 12 },
									count: 5,
									callback: (value) => formatNumberShort(value)
								},
								grid: { color: "#444" },
								afterFit: (axis) => { axis.width = 70; }
							},
							x: {
								ticks: {
									color: '#fff',
									font: { size: 12 }
								},
								grid: { color: "#444" }
							}
						}
					}
				});

				charts.push(chart);
			});
		}

		// Show/hide slider window when charts visible
		window.addEventListener('scroll', () => {
			const chartsDiv = document.getElementById('charts');
			const rect = chartsDiv.getBoundingClientRect();
			const slider = document.getElementById('entitySliderWrapper');

			if (rect.top < window.innerHeight && rect.bottom > 0) {
				slider.style.display = 'block';
			} else {
				slider.style.display = 'none';
			}
		});

		// Make slider draggable
		(function makeDraggable() {
			const sliderWindow = document.getElementById('entitySliderWrapper');
			let offsetX, offsetY, isDragging = false;

			sliderWindow.addEventListener('mousedown', (e) => {
				if (e.target.tagName === 'INPUT' || e.target.id === 'sliderTicks') {
					return;
				}

				isDragging = true;
				const rect = sliderWindow.getBoundingClientRect();
				offsetX = e.clientX - rect.left;
				offsetY = e.clientY - rect.top;
				document.body.style.userSelect = "none";
			});

			document.addEventListener('mousemove', (e) => {
				if (!isDragging) return;
				sliderWindow.style.left = (e.clientX - offsetX) + "px";
				sliderWindow.style.top = (e.clientY - offsetY) + "px";
				sliderWindow.style.right = "auto";
				sliderWindow.style.bottom = "auto";
				sliderWindow.style.position = "fixed";
			});

			document.addEventListener('mouseup', () => {
				isDragging = false;
				document.body.style.userSelect = "";
			});
		})();

		loadData();
	</script>
</body>

</html>