<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>ecss vs other ecs benchmarks</title>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		.section-separator {
			border: none;
			height: 1px;
			margin: 40px 0;
			background: linear-gradient(to right, transparent, #444, transparent);
			width: 100%;
		}

		.result-table {
			display: flex;
			flex-direction: column;
			gap: 6px;
			font-family: monospace;
		}

		.result-table .row {
			display: flex;
			justify-content: space-between;
			padding: 2px 6px;
			background: #1e1e1e;
			border-radius: 4px;
		}

		.result-table .name {
			color: #e0e0e0;
		}

		.result-table .value {
			color: #82cfff;
		}

		.info-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 40px;
			margin-bottom: 20px;
		}

		.info-grid h3 {
			margin-top: 0;
		}

		#system-info pre,
		#ecss-summary pre {
			background: #1e1e1e;
			padding: 10px;
			border-radius: 6px;
			overflow-x: auto;
		}

		a {
			color: #4ea3ff;
			text-decoration: none;
		}

		a:hover {
			text-decoration: underline;
			color: #82cfff;
		}

		body {
			margin: 0;
			font-family: sans-serif;
			background: #121212;
			color: #e0e0e0;
		}

		h1 {
			padding: 20px;
			text-align: center;
		}

		#charts {
			display: grid;
			grid-template-columns: repeat(2, 1fr);
			grid-gap: 20px;
			padding: 20px;
			box-sizing: border-box;
		}

		.chart-container {
			background: #1e1e1e;
			border-radius: 8px;
			padding: 10px;
			box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
			height: 300px;
		}

		canvas {
			width: 100% !important;
			height: 100% !important;
		}

		#toggleScale {
			position: fixed;
			bottom: 20px;
			right: 20px;
			padding: 10px 18px;
			background: rgba(50, 50, 50, 0.6);
			color: #fff;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			font-size: 14px;
			z-index: 1000;
			transition: background 0.3s, opacity 0.3s;
		}

		#toggleScale:hover {
			background: rgba(70, 70, 70, 0.9);
			opacity: 1;
		}
	</style>
</head>

<body>
	<div style="padding:20px; margin:0 auto; line-height:1.6;">
		<h2>ECSS Benchamrks</h2>
		<div class="info-grid">
			<div>
				<h3>System Info</h3>
				<div id="system-info"></div>
			</div>
			<div>
				<h3>ecss – 1M entity results</h3>
				<div id="ecss-summary"></div>
			</div>
		</div>
	</div> <!-- closes your centered intro -->
	<hr class="section-separator">
	<div style="padding:20px; margin:0 auto; line-height:1.6;"> <!-- next block -->
		<h2>About these benchmarks</h2>
		<p>
			This page shows performance comparisons of different ECS implementations.<br>
			<strong>Lower values mean better performance.</strong>
			Times are reported in microseconds (µs) per operation, across varying entity counts.
		</p>



		<h3>Compared ECS libraries</h3>
		<ul>
			<li><a href="https://github.com/wagnerks/ecss" target="_blank">ecss</a> – sector/chunk based ECS (this repo)</li>
			<li><a href="https://github.com/skypjack/entt" target="_blank">EnTT</a> – widely used archetype-based ECS</li>
		</ul>

		<p>
			Benchmark sources live here:
			<a href="https://github.com/wagnerks/ecss_benchmarks" target="_blank">wagnerks/ecss_benchmarks</a>.
		</p>
	</div>
	<button id="toggleScale">Switch to Log Scale</button>

	<div id="charts"></div>

	<script>
		let charts = [];
		let useLogScale = false;

		function enhanceChart(chart) {
			let hoverTimer = null;
			let lastIndex = null;

			chart.canvas.addEventListener('mousemove', (evt) => {
				const { left, right, top, bottom } = chart.chartArea;

				// ignore if mouse is outside the bars area
				if (evt.offsetX < left || evt.offsetX > right || evt.offsetY < top || evt.offsetY > bottom) {
					clearTimeout(hoverTimer);
					hoverTimer = null;
					lastIndex = null;
					chart.options.scales.y.max = undefined;
					chart.update(); // smooth transition
					return;
				}

				const rect = chart.canvas.getBoundingClientRect();
				const x = evt.clientX - rect.left;
				let nearestIndex = -1;

				chart.data.labels.forEach((label, idx) => {
					let minBarLeft = Infinity;
					let maxBarRight = -Infinity;
					for (let dsIdx = 0; dsIdx < chart.data.datasets.length; dsIdx++) {
						const meta = chart.getDatasetMeta(dsIdx);
						const bar = meta.data[idx];
						if (bar) {
							const barLeft = bar.x - (bar.width || 20) / 2;
							const barRight = bar.x + (bar.width || 20) / 2;
							if (barLeft < minBarLeft) minBarLeft = barLeft;
							if (barRight > maxBarRight) maxBarRight = barRight;
						}
					}
					if (x >= minBarLeft && x <= maxBarRight) {
						nearestIndex = idx;
					}
				});

				if (nearestIndex !== lastIndex) {
					lastIndex = nearestIndex;
					clearTimeout(hoverTimer);

					if (nearestIndex >= 0) {
						hoverTimer = setTimeout(() => {
							const values = chart.data.datasets.map(ds => ds.data[nearestIndex]).filter(v => v != null);
							if (values.length > 0) {
								const maxVal = Math.max(...values);
								chart.options.scales.y.max = Math.ceil(maxVal * 1.1);
								chart.update();
							}
						}, 250);
					}
				}
			});

			chart.canvas.addEventListener('mouseleave', () => {
				clearTimeout(hoverTimer);
				hoverTimer = null;
				lastIndex = null;
				chart.options.scales.y.max = undefined;
				chart.update();
			});
		}
		async function loadSummary(json) {
			const ctx = json.context;

			const sysInfo = [
				`Date: ${ctx.date}`,
				`Host: ${ctx.host_name}`,
				`Executable: ${ctx.executable}`,
				`CPU cores: ${ctx.num_cpus}`,
				`Clock: ${ctx.mhz_per_cpu} MHz`,
				`CPU scaling: ${ctx.cpu_scaling_enabled ? "enabled" : "disabled"}`,
				`Build type: ${ctx.library_build_type}`,
				`Load avg: ${ctx.load_avg.join(", ")}`
			];

			// format caches
			if (ctx.caches && ctx.caches.length > 0) {
				sysInfo.push("Caches:");
				ctx.caches.forEach(c => {
					sysInfo.push(
						`  L${c.level} ${c.type} – ${c.size / 1024} KB (shared by ${c.num_sharing})`
					);
				});
			}

			document.getElementById('system-info').innerHTML =
				"<pre>" + sysInfo.join("\n") + "</pre>";

			// only ecss with 1M
			const oneM = {};
			json.benchmarks.forEach(b => {
				const match = b.name.match(/ecss.*?([a-zA-Z_]+)\/1000000/);
				if (match) {
					const [, testName] = match;
					oneM[testName] = Math.round(b.cpu_time);
				}
			});

			// build table-like block
			let html = "<div class='result-table'>";
			Object.entries(oneM).forEach(([test, val]) => {
				html += `<div class="row"><span class="name">${test}</span><span class="value">${val} µs</span></div>`;
			});
			html += "</div>";

			document.getElementById("ecss-summary").innerHTML = html;
		}

		async function loadData() {
			const response = await fetch('results.json');
			const json = await response.json();
			loadSummary(json);

			const groups = {};
			json.benchmarks.forEach(b => {
				const match = b.name.match(/(ecss|entt).*?([a-zA-Z_]+)\/(\d+)/);
				if (!match) return;
				const [, ecs, testName, size] = match;
				if (!groups[testName]) groups[testName] = {};
				if (!groups[testName][size]) groups[testName][size] = {};
				groups[testName][size][ecs] = b.cpu_time;
			});

			const chartsDiv = document.getElementById('charts');

			Object.entries(groups).forEach(([testName, sizes]) => {
				const container = document.createElement('div');
				container.className = 'chart-container';
				const canvas = document.createElement('canvas');
				container.appendChild(canvas);
				chartsDiv.appendChild(container);

				const labels = Object.keys(sizes).map(s => parseInt(s));
				const ecssData = labels.map(s => sizes[s].ecss || null);
				const enttData = labels.map(s => sizes[s].entt || null);

				const chart = new Chart(canvas.getContext('2d'), {
					data: {
						labels,
						datasets: [
							{
								type: 'bar',
								label: 'ecss',
								data: ecssData,
								backgroundColor: 'rgba(145, 121, 201, 0.7)'
							},
							{
								type: 'bar',
								label: 'entt',
								data: enttData,
								backgroundColor: 'rgba(50, 128, 50, 0.7)'
							}
						]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						animation: {
							duration: 500,   // 0.5s
							easing: 'easeOutCubic'
						},
						plugins: {
							title: {
								display: true,
								text: testName,
								color: '#fff',
								font: { size: 16 }
							},
							legend: {
								labels: {
									color: '#fff',
									font: { size: 14 }
								}
							}
						},
						scales: {
							y: {
								type: useLogScale ? 'logarithmic' : 'linear',
								beginAtZero: false,
								title: {
									display: true,
									text: 'Time (µs)',
									color: '#fff',
									font: { size: 14 }
								},
								ticks: {
									color: '#fff',
									font: { size: 12 },
									count: 5
								},
								grid: { color: "#444" },
								afterFit: (axis) => { axis.width = 90; } // px reserved for labels
							},
							x: {
								title: {
									display: true,
									text: 'Entities',
									color: '#fff',
									font: { size: 14 }
								},
								ticks: {
									color: '#fff',
									font: { size: 12 }
								},
								grid: { color: "#444" }
							}
						}
					}
				});

				enhanceChart(chart);
				charts.push(chart);

			});
		}



		document.getElementById('toggleScale').addEventListener('click', () => {
			useLogScale = !useLogScale;
			charts.forEach(chart => {
				chart.options.scales.y.type = useLogScale ? 'logarithmic' : 'linear';
				chart.update();
			});
			document.getElementById('toggleScale').innerText = useLogScale ? "Switch to Linear Scale" : "Switch to Log Scale";
		});

		loadData();

	</script>
</body>

</html>