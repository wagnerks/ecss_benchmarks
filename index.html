<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<title>ecss benchmarks</title>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<style>
		a {
			color: #4ea3ff;
			text-decoration: none;
		}

		a:hover {
			text-decoration: underline;
			color: #82cfff;
		}

		body {
			margin: 0;
			font-family: sans-serif;
			background: #121212;
			color: #e0e0e0;
		}

		#charts {
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
			grid-gap: 20px;
			padding: 20px;
			box-sizing: border-box;
		}

		.chart-container {
			background: #1e1e1e;
			border-radius: 8px;
			padding: 10px;
			box-shadow: 0 2px 6px rgba(0, 0, 0, 0.7);
			height: 200px;
		}

		canvas {
			width: 100% !important;
			height: 100% !important;
		}

		.section-separator {
			border: none;
			height: 1px;
			margin: 1px 0;
			background: linear-gradient(to right, transparent, #444, transparent);
			width: 100%;
		}

		.result-table {
			display: flex;
			flex-direction: column;
			gap: 6px;
			font-family: monospace;
		}

		.result-table .row {
			display: flex;
			justify-content: space-between;
			padding: 2px 6px;
			background: #1e1e1e;
			border-radius: 4px;
		}

		.result-table .name {
			color: #e0e0e0;
		}

		.result-table .value {
			color: #82cfff;
		}

		.info-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 40px;
			margin-bottom: 20px;
		}

		.info-grid h3 {
			margin-top: 0;
		}

		#system-info pre,
		#ecss-summary pre {
			background: #1e1e1e;
			padding: 10px;
			border-radius: 6px;
			overflow-x: auto;
		}

		.compare-slider {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 40px;
			align-items: start;
			padding: 10px;
			max-width: 1920px;
			margin: 0 auto;
			box-sizing: border-box;
		}

		.compare-text {
			line-height: 1.6;
		}

		.controls-wrapper {
			background: rgba(30, 30, 30, 0.6);
			border-radius: 8px;
			padding: 12px 16px;
			box-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
			opacity: 0.9;
		}

		.controls-wrapper:hover {
			background: rgba(30, 30, 30, 0.9);
			opacity: 1;
		}

		.controls-wrapper label {
			font-size: 13px;
			margin-bottom: 6px;
			display: block;
			color: #ddd;
		}

		#entityCount {
			width: 100%;
		}

		#sliderTicks {
			display: flex;
			justify-content: space-between;
			margin-top: 4px;
			font-size: 11px;
			color: #aaa;
			font-family: monospace;
		}

		.compiler-selector {
			display: flex;
			gap: 8px;
			margin-bottom: 16px;
		}

		.compiler-btn {
			padding: 8px 16px;
			border: 1px solid #444;
			background: #1e1e1e;
			color: #e0e0e0;
			border-radius: 6px;
			cursor: pointer;
			font-size: 13px;
			transition: all 0.2s ease;
		}

		.compiler-btn:hover {
			background: #2a2a2a;
			border-color: #666;
		}

		.compiler-btn.active {
			background: #4ea3ff;
			color: #121212;
			border-color: #4ea3ff;
			font-weight: bold;
		}

		.compiler-btn.active:hover {
			background: #6bb3ff;
		}

		.control-group {
			margin-bottom: 12px;
		}

		.control-group:last-child {
			margin-bottom: 0;
		}

		.control-label {
			font-size: 12px;
			color: #888;
			margin-bottom: 6px;
			text-transform: uppercase;
			letter-spacing: 0.5px;
		}

		.loading-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(18, 18, 18, 0.9);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 1000;
			opacity: 0;
			pointer-events: none;
			transition: opacity 0.3s ease;
		}

		.loading-overlay.visible {
			opacity: 1;
			pointer-events: auto;
		}

		.loading-spinner {
			width: 50px;
			height: 50px;
			border: 3px solid #333;
			border-top-color: #4ea3ff;
			border-radius: 50%;
			animation: spin 1s linear infinite;
		}

		@keyframes spin {
			to { transform: rotate(360deg); }
		}

		.error-message {
			background: #3a1a1a;
			border: 1px solid #662222;
			color: #ff8888;
			padding: 10px 16px;
			border-radius: 6px;
			margin: 10px 0;
			font-size: 13px;
		}
	</style>
</head>

<body>
	<div id="loading" class="loading-overlay">
		<div class="loading-spinner"></div>
	</div>

	<div style="padding:10px; max-width:1920px; margin:0 auto; line-height:1.6;">
		<h2><a href="https://github.com/wagnerks/ecss_benchmarks" target="_blank">ECSS Benchmarks</a>, <a
				href="https://github.com/wagnerks/ecss" target="_blank">ecss</a> – sector/chunk based ECS
		</h2>

		<div class="info-grid">
			<div>
				<h3>System Info</h3>
				<div id="system-info"></div>
			</div>
			<div>
				<h3>ecss – 1M entity results</h3>
				<div id="ecss-summary"></div>
			</div>
		</div>
	</div>
	
	<hr class="section-separator">

	<div class="compare-slider">
		<div class="compare-text">
			<h3>Compared to:</h3>
			<ul>
				<li><strong>vec</strong> – raw std::vector baseline (SoA, theoretical minimum)</li>
				<li><a href="https://github.com/skypjack/entt" target="_blank">EnTT</a> – is a header-only, tiny and
					easy to use library for game programming and much more written in modern C++.</li>
				<li><a href="https://github.com/SanderMertens/flecs" target="_blank">Flecs</a> – Flecs is a fast and
					lightweight Entity Component System that lets you build games and simulations with millions of
					entities
				</li>
			</ul>
			<p>
				<strong>Lower values mean better performance.</strong><br>
				Bars show relative performance with <strong>ecss = 1×</strong> as the baseline.
				Other libraries are divided by the ecss result, so you can directly compare how
				many times slower or faster they are. Absolute times in microseconds (µs) are
				available in tooltips when hovering over a bar.
			</p>
			<p style="font-size: 12px; color: #888; margin-top: 12px;">
				<strong>Note:</strong> GCC aggressively auto-vectorizes simple loops (vec, Flecs), 
				making them faster on Linux. MSVC doesn't vectorize as well, so <strong>ECSS performs better on Windows</strong> — 
				the most common platform for game development.
			</p>
		</div>

		<div class="controls-wrapper">
			<div class="control-group">
				<div class="control-label">Compiler</div>
				<div class="compiler-selector">
					<button class="compiler-btn" data-compiler="gcc">GCC (Linux)</button>
					<button class="compiler-btn active" data-compiler="msvc">MSVC (Windows)</button>
				</div>
				<div id="compiler-error" class="error-message" style="display: none;"></div>
			</div>
			
			<div class="control-group">
				<label for="entityCount">
					Entities count: <span id="entityLabel"></span>
				</label>
				<input type="range" id="entityCount" min="0" step="1" value="0" onfocus="this.blur()">
				<div class="ticks" id="sliderTicks"></div>
			</div>
		</div>
	</div>

	<div id="charts-wrapper">
		<div id="charts"></div>
	</div>

	<script>
		let charts = {};
		let allGroups = {};
		let availableSizes = [];
		let currentIndex = 0;
		let currentCompiler = 'msvc';
		let jsonCache = {};

		function showLoading(show) {
			document.getElementById('loading').classList.toggle('visible', show);
		}

		function showError(message) {
			const errorDiv = document.getElementById('compiler-error');
			if (message) {
				errorDiv.textContent = message;
				errorDiv.style.display = 'block';
			} else {
				errorDiv.style.display = 'none';
			}
		}

		function formatNumberShort(n) {
			if (n >= 1_000_000) return (n / 1_000_000) + "M";
			if (n >= 1_000) return (n / 1_000) + "K";
			return n.toString();
		}

		function updateSliderLabel() {
			document.getElementById("entityLabel").textContent =
				formatNumberShort(availableSizes[currentIndex]);
		}

		async function loadSummary(json) {
			const ctx = json.context;
			const sysInfo = [
				`Date: ${ctx.date}`,
				`Host: ${ctx.host_name}`,
				`Executable: ${ctx.executable}`,
				`CPU cores: ${ctx.num_cpus}`,
				`Clock: ${ctx.mhz_per_cpu} MHz`,
				`CPU scaling: ${ctx.cpu_scaling_enabled ? "enabled" : "disabled"}`,
				`Build type: ${ctx.library_build_type}`,
				`Load avg: ${ctx.load_avg.join(", ")}`,
				`Compiler: ${currentCompiler.toUpperCase()}`
			];
			if (ctx.caches && ctx.caches.length > 0) {
				sysInfo.push("Caches:");
				ctx.caches.forEach(c => {
					sysInfo.push(`  L${c.level} ${c.type} – ${c.size / 1024} KB (shared by ${c.num_sharing})`);
				});
			}
			document.getElementById('system-info').innerHTML =
				"<pre>" + sysInfo.join("\n") + "</pre>";

			const oneM = {};
			json.benchmarks.forEach(b => {
				const match = b.name.match(/ecss.*?([a-zA-Z_]+)\/1000000/);
				if (match) {
					const [, testName] = match;
					oneM[testName] = Math.round(b.cpu_time);
				}
			});

			let html = "<div class='result-table'>";
			Object.entries(oneM).forEach(([test, val]) => {
				html += `<div class="row"><span class="name">${test}</span><span class="value">${val} µs</span></div>`;
			});
			html += "</div>";
			document.getElementById("ecss-summary").innerHTML = html;
		}

		function getResultsUrl(compiler) {
			// Use minified JSON files for faster loading
			if (compiler === 'gcc') {
				return 'results-gcc.min.json';
			} else if (compiler === 'msvc') {
				return 'results-msvc.min.json';
			}
			return 'results.json';
		}

		async function loadData(compiler = 'gcc') {
			showLoading(true);
			showError(null);
			
			let json;
			
			// Check cache first
			if (jsonCache[compiler]) {
				json = jsonCache[compiler];
			} else {
				const url = getResultsUrl(compiler);
				
				try {
					const response = await fetch(url + '?ts=' + Date.now());
					if (!response.ok) {
						// Fallback to legacy results.json
						if (compiler !== 'legacy') {
							const fallbackResponse = await fetch('results.json?ts=' + Date.now());
							if (fallbackResponse.ok) {
								json = await fallbackResponse.json();
								showError(`No ${compiler.toUpperCase()} results yet. Showing legacy results.`);
							} else {
								throw new Error('No benchmark results available');
							}
						} else {
							throw new Error('No benchmark results available');
						}
					} else {
						json = await response.json();
					}
					jsonCache[compiler] = json;
				} catch (e) {
					showLoading(false);
					showError(`Failed to load ${compiler.toUpperCase()} results: ${e.message}`);
					return;
				}
			}

			loadSummary(json);

			const groups = {};
			const sizesSet = new Set();

			json.benchmarks.forEach(b => {
				const match = b.name.match(/(vec|ecss|entt|flecs).*?([a-zA-Z_]+)\/(\d+)$/);
				if (!match) return;
				const [, ecs, rawName, size] = match;
				const testName = rawName.replace(/[^a-zA-Z0-9_]/g, '');

				if (!groups[testName]) groups[testName] = {};
				if (!groups[testName][size]) groups[testName][size] = {};
				groups[testName][size][ecs] = b.cpu_time;
				sizesSet.add(parseInt(size));
			});

			allGroups = groups;
			availableSizes = Array.from(sizesSet).sort((a, b) => a - b);

			const slider = document.getElementById('entityCount');
			slider.max = availableSizes.length - 1;
			slider.value = availableSizes.length - 1;
			currentIndex = parseInt(slider.value, 10);

			const ticksDiv = document.getElementById('sliderTicks');
			ticksDiv.innerHTML = availableSizes.map(s => `<span>${formatNumberShort(s)}</span>`).join('');

			renderCharts(availableSizes[currentIndex]);
			updateSliderLabel();
			showLoading(false);
		}

		function prepareData(sizeData) {
			const ecssData = sizeData.ecss || 1;
			return [
				sizeData.vec ? sizeData.vec / ecssData : null,
				1,
				sizeData.entt ? sizeData.entt / ecssData : null,
				sizeData.flecs ? sizeData.flecs / ecssData : null
			];
		}

		function setCustomTicks(chart, newData) {
			const ticks = newData.filter(v => v !== null);
			chart.options.scales.y.afterBuildTicks = (axis) => {
				axis.ticks = ticks.map(v => ({ value: v }));
			};
		}

		const valueOnBars = {
			id: 'valueOnBars',
			afterDatasetsDraw(chart) {
				const { ctx } = chart;
				ctx.save();
				chart.data.datasets.forEach((dataset, i) => {
					const meta = chart.getDatasetMeta(i);
					meta.data.forEach((bar, index) => {
						const val = dataset.data[index];
						if (val !== null && val !== undefined) {
							ctx.fillStyle = '#fff';
							ctx.font = '12px sans-serif';
							ctx.textAlign = 'center';
							function formatRatio(val) {
								if (Math.abs(val - Math.round(val)) < 1e-6) {
									return Math.round(val).toString();
								}
								if (val < 5) {
									return val.toFixed(2);
								}
								return Math.round(val).toString();
							}

							ctx.fillText(
								formatRatio(val) + "×",
								bar.x,
								bar.y - 5
							);
						}
					});
				});
			}
		};

		function renderCharts(entityCount) {
			const chartsDiv = document.getElementById('charts');
			chartsDiv.innerHTML = '';
			charts = {};

			Object.entries(allGroups).forEach(([testName, sizes]) => {
				if (!sizes[entityCount]) return;

				const container = document.createElement('div');
				container.className = 'chart-container';
				const canvas = document.createElement('canvas');
				canvas.dataset.test = testName;
				container.appendChild(canvas);
				chartsDiv.appendChild(container);

				const chartData = prepareData(sizes[entityCount]);
				const chart = new Chart(canvas.getContext('2d'), {
					type: 'bar',
					data: {
						labels: ['vec', 'ecss', 'entt', 'flecs'],
						datasets: [{
							label: testName,
							data: chartData,
							backgroundColor: [
								'rgba(100, 100, 100, 0.7)',
								'rgba(145, 121, 201, 0.7)',
								'rgba(50, 128, 50, 0.7)',
								'rgba(200, 100, 50, 0.7)'
							],
						}]
					},
					options: {
						responsive: true,
						maintainAspectRatio: false,
						animation: { duration: 0 },
						plugins: {
							legend: { display: false },
							title: {
								display: true,
								text: testName,
								color: '#fff',
								font: { size: 14 }
							},
							tooltip: {
								displayColors: false,
								callbacks: {
									title: () => [],
									label: (ctx) => {
										const sizeData = allGroups[testName][entityCount];
										const ecssVal = sizeData.ecss || 1;

										if (ctx.dataIndex === 0 && sizeData.vec)
											return `${sizeData.vec.toFixed(0)} µs`;
										if (ctx.dataIndex === 1)
											return `${ecssVal.toFixed(0)} µs`;
										if (ctx.dataIndex === 2 && sizeData.entt)
											return `${sizeData.entt.toFixed(0)} µs`;
										if (ctx.dataIndex === 3 && sizeData.flecs)
											return `${sizeData.flecs.toFixed(0)} µs`;
										return "";
									}
								}
							}
						},
						scales: {
							y: {
								type: 'linear',
								ticks: {
									display: false,
									color: '#fff',
									font: { size: 12 },
									callback: (value) => value.toFixed(2) + "×"
								},
								grid: {
									display: false,
									color: "#444",
									drawOnChartArea: true
								},
								afterBuildTicks: (axis) => {
									const chartData = axis.chart.data.datasets[0].data;
									const ticks = chartData.filter(v => v !== null);
									axis.ticks = ticks.map(v => ({ value: v }));
								},
								border: {
									display: false,
									color: "#888"
								}
							},
							x: {
								ticks: {
									color: '#fff',
									font: { size: 12 }
								},
								grid: {
									display: false,
									color: "#444"
								},
								border: {
									color: "#888"
								}
							}
						}
					},
					plugins: [valueOnBars]
				});

				setCustomTicks(chart, chartData);
				charts[testName] = chart;
			});
		}

		function updateChartsData(entityCount) {
			Object.entries(allGroups).forEach(([testName, sizes]) => {
				if (!sizes[entityCount]) return;
				const chart = charts[testName];
				if (!chart) return;

				const newData = prepareData(sizes[entityCount]);
				chart.data.datasets[0].data = newData;
				setCustomTicks(chart, newData);

				chart.update();
			});
		}

		// Initialize
		document.querySelectorAll('.compiler-btn').forEach(btn => {
			btn.addEventListener('click', async (e) => {
				const compiler = e.target.dataset.compiler;
				if (compiler === currentCompiler) return;
				
				document.querySelectorAll('.compiler-btn').forEach(b => b.classList.remove('active'));
				e.target.classList.add('active');
				
				currentCompiler = compiler;
				await loadData(compiler);
			});
		});

		document.getElementById('entityCount').addEventListener('input', (e) => {
			currentIndex = parseInt(e.target.value, 10);
			updateChartsData(availableSizes[currentIndex]);
			updateSliderLabel();
		});

		loadData('msvc');
	</script>
</body>

</html>
